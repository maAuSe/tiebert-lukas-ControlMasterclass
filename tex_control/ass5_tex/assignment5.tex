\documentclass{article}
\usepackage{graphicx}
\usepackage{adjustbox}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{booktabs}
\usepackage{hyperref}
\usepackage{geometry}
\usepackage{siunitx}
\geometry{margin=1in}

\begin{document}

\begin{titlepage}
  \thispagestyle{empty}
  \pagenumbering{Roman}
  \frenchspacing

  \noindent
  \begin{tabular}{@{} c @{\hspace{0.1cm}} c @{\hspace{0.2cm}} c @{}}
    \adjustbox{valign=c}{\includegraphics[height=2cm]{sedes.pdf}} &
    \adjustbox{valign=c}{\rule{0.5pt}{2cm}} &
    \adjustbox{valign=c}{\includegraphics[height=2cm]{logoFirW.jpg}}
  \end{tabular}
  \hfill

  \vspace*{2cm}
  \begin{center}
    \Large\textbf{B-KUL-H04X3A: Control Theory}\\[5mm]
    \Large Team members: Lefebure Tiebert (r0887630), Campaert Lukas (r0885501)\\[12mm]
    \Huge\textbf{Assignment 5: Estimation and control of a two-wheel driven cart}\\[12mm]
  \end{center}
  \vfill
\end{titlepage}

\setcounter{page}{1}
\pagenumbering{arabic}

\section{Model the system}
\subsection*{(a) State equation and relation between motor commands and $(v,\omega)$}
The cart is driven by two actuators located a distance $2b$ apart (wheelbase) with wheel radius $r$ and wheel speeds $\omega_L,\omega_R$ (rad/s). Forward and rotational velocities follow immediately from rigid-body constraints,
\begin{equation}
  v = \frac{r}{2}(\omega_L+\omega_R), \qquad
  \omega = \frac{r}{2b}(\omega_R-\omega_L),
  \label{eq:inputs_to_wheels}
\end{equation}
and the individual wheel speeds required to realise a commanded $(v,\omega)$ are
\begin{equation}
  \omega_L = \frac{1}{r}\big(v - b\,\omega\big), \qquad
  \omega_R = \frac{1}{r}\big(v + b\,\omega\big).
\end{equation}
Using $\xi = [x_c\;y_c\;\theta]^T$ to denote the centre pose of the cart in the inertial $XY$ frame and $u=[v\;\omega]^T$, the nonlinear continuous-time state-space model is
\begin{equation}
  \dot{\xi} = f(\xi,u) =
  \begin{bmatrix}
    v \cos\theta\\
    v \sin\theta\\
    \omega
  \end{bmatrix},
  \qquad
  \xi(t_0) = [x_0\;y_0\;\theta_0]^T.
  \label{eq:state_equation}
\end{equation}
This model assumes ideal velocity tracking and neglects wheel slip, which is consistent with the assignment statement.

\subsection*{(b) Measurement equation (general and Figure 4)}
Any wall is characterised by $\mathcal{W}=\{(x,y)\mid px + qy = r\}$ with outward unit normal $\hat{n}= \frac{1}{\sqrt{p^2+q^2}}[p\;q]^T$. The front infrared (IR) sensor is at $(\alpha,0)$ in the body-fixed frame, while the lateral sensor is at $(\beta,\gamma)$ with $\gamma>0$ pointing to the left of the chassis. Expressing these points in world coordinates yields
\begin{align}
  x_f &= x_c + \alpha \cos\theta, \qquad y_f = y_c + \alpha\sin\theta,\\
  x_s &= x_c + \beta\cos\theta - \gamma\sin\theta, \qquad
  y_s = y_c + \beta\sin\theta + \gamma\cos\theta.
\end{align}
The signed distance from a sensor position $(x,y)$ to a wall is
\begin{equation}
  h(x,y;p,q,r) = \frac{r - p x - q y}{\sqrt{p^2+q^2}},
\end{equation}
which defines the nonlinear measurement equations
\begin{equation}
  z =
  \begin{bmatrix}
    z_1 \\ z_2
  \end{bmatrix}
  =
  \begin{bmatrix}
    h(x_f,y_f;p_1,q_1,r_1)\\
    h(x_s,y_s;p_2,q_2,r_2)
  \end{bmatrix}
  + v_m, \qquad v_m \sim \mathcal{N}(0,R).
  \label{eq:measurement_equation}
\end{equation}
For the geometry in Figure~4, the front sensor faces a horizontal wall at $y=0$ and the lateral sensor faces a vertical wall at $x=0$, i.e. $(p_1,q_1,r_1)=(0,1,0)$, $(p_2,q_2,r_2)=(1,0,0)$. Equation~\eqref{eq:measurement_equation} then simplifies to $z_1 = - y_f$ and $z_2 = - x_s$ while the offsets $\alpha,\beta,\gamma,a$ remain explicit in $x_f,y_f,x_s,y_s$.

\section{Derive and discuss the extended Kalman filter}
\subsection*{(a) Forward Euler discretisation of model and measurements}
Let $T_s$ be the sampling interval. Applying forward Euler to~\eqref{eq:state_equation} produces the discrete-time process model
\begin{equation}
  \xi_{k+1} = \xi_k + T_s f(\xi_k,u_k) + w_k,
  \qquad w_k \sim \mathcal{N}(0,Q),
  \label{eq:discrete_state}
\end{equation}
where $w_k$ absorbs the effect of process disturbances, encoder quantisation and modelling residuals. The measurement equation~\eqref{eq:measurement_equation} is already instantaneous; sample-and-hold leads to
\begin{equation}
  z_k = h(\xi_k) + v_k,\qquad v_k \sim \mathcal{N}(0,R),
  \label{eq:discrete_measurement}
\end{equation}
where $v_k$ models sensor noise and calibration errors. Equations~\eqref{eq:discrete_state}--\eqref{eq:discrete_measurement} are the nonlinear basis for the EKF.

\subsection*{(b) Linearisation point and Jacobians}
Linearising~\eqref{eq:discrete_state} around a nominal state $\xi^\ast$ and input $u^\ast$ yields
\begin{equation}
  \delta \xi_{k+1} = A_k \delta \xi_k + B_k \delta u_k + w_k, \qquad
  \delta z_k = C_k \delta \xi_k + v_k,
\end{equation}
with Jacobians evaluated at $(\xi^\ast,u^\ast)$,
\begin{align}
  A_k &= \frac{\partial (\xi_k + T_s f(\xi_k,u_k))}{\partial \xi}\Big|_{\xi^\ast,u^\ast}
  =
  \begin{bmatrix}
    1 & 0 & -T_s v^\ast \sin\theta^\ast\\
    0 & 1 &  T_s v^\ast \cos\theta^\ast\\
    0 & 0 &  1
  \end{bmatrix},\\
  B_k &= \frac{\partial (\xi_k + T_s f(\xi_k,u_k))}{\partial u}\Big|_{\xi^\ast,u^\ast}
  =
  \begin{bmatrix}
    T_s \cos\theta^\ast & 0\\
    T_s \sin\theta^\ast & 0\\
    0 & T_s
  \end{bmatrix},\\
  C_k &= \frac{\partial h(\xi_k)}{\partial \xi}\Big|_{\xi^\ast} =
  \begin{bmatrix}
    -\frac{p_1}{n_1} & -\frac{q_1}{n_1} &
    -\frac{p_1 \dot{x}_f^\ast + q_1 \dot{y}_f^\ast}{n_1}\\[2mm]
    -\frac{p_2}{n_2} & -\frac{q_2}{n_2} &
    -\frac{p_2 \dot{x}_s^\ast + q_2 \dot{y}_s^\ast}{n_2}
  \end{bmatrix},
\end{align}
with $n_i = \sqrt{p_i^2 + q_i^2}$ and
\begin{align*}
  \dot{x}_f^\ast &= -\alpha \sin\theta^\ast, &\quad \dot{y}_f^\ast &= \alpha \cos\theta^\ast,\\
  \dot{x}_s^\ast &= -\beta \sin\theta^\ast - \gamma \cos\theta^\ast, &
  \dot{y}_s^\ast &= \beta \cos\theta^\ast - \gamma \sin\theta^\ast.
\end{align*}
For the Figure~4 walls one obtains
\begin{equation}
  C_k =
  \begin{bmatrix}
    0 & -1 & -\alpha \cos\theta^\ast\\
    -1 & 0 & \beta\sin\theta^\ast + \gamma \cos\theta^\ast
  \end{bmatrix}.
\end{equation}
The extended Kalman filter recomputes $A_k$ and $C_k$ at every step by choosing $\xi^\ast = \hat{\xi}_{k|k-1}$, while a linear Kalman filter would keep $(A,B,C)$ fixed around a single operating point $\xi^\star$ and is therefore only valid for small deviations from that point. In low-curvature straight-line motion the time-invariant linearisation around $\theta^\star$ close to the true motion is acceptable. During turns, however, curvature makes the discrepancy between $\theta^\star$ and $\theta_k$ appreciable and the EKF is needed for consistency.

\subsection*{(c) Suitability of linear versus extended Kalman filters}
Both Kalman filter variants rely on the same Gaussian assumptions for $w_k$ and $v_k$; no change in noise statistics is implied when switching between linear and extended formulations. The linear Kalman filter uses the linearised dynamics for both prediction and correction, while the EKF predicts with the full nonlinear model and only linearises locally for covariance propagation and measurement updates. Consequently, the EKF maintains accuracy over the entire specified trajectory (straight segment, coordinated turn, second straight), whereas the linear filter is only satisfactory when $|\theta_k - \theta^\star|\ll 1$ and the sensors see walls that align with the linearisation point. In practice the two infrared sensors provide strong geometric constraints before the turn, so both filters behave similarly in that phase. Once the cart turns away from the walls, the nonlinear coupling between $x$, $y$ and $\theta$ dominates and the EKF preserves observability, while the fixed linear-model assumption leads to biased estimation and inflated residuals.

\section{Design and implementation of the extended Kalman filter}
\subsection*{(a) Sources of process and measurement noise}
Process noise $Q$ captures uncertainties on the motion model: unequal wheel radii, wheel slip on smooth tiles, discrepancies between commanded and realised wheel speeds, encoder quantisation (especially for small $\omega$), and neglected swivel-caster dynamics. Measurement noise $R$ collects sensor-specific effects: IR time-of-flight noise, non-specular reflections from walls of varying material, temperature-dependent gain of the analog front-end, and the fact that offsets $\alpha,\beta,\gamma$ cannot be measured perfectly. Approximating the cart as a rigid body with instantaneous velocity tracking shifts the remaining mismatch into the process noise term.

\subsection*{(b) EKF implementation, choice of $Q$, $R$, and $\hat{P}_{0|0}$}
The Arduino implementation follows the provided \texttt{CT-EKF-Swivel} template. The state estimate and covariance are initialised in \texttt{resetKalmanFilter()}, and matrices are tuned via the constants \texttt{kQx}, \texttt{kQy}, \texttt{kQtheta}, \texttt{kRz1} (front sensor) and \texttt{kRz2} (side sensor). A reasonable starting point consistent with the MATLAB script is
\begin{align*}
  Q &= \text{diag}\big(1.0\times 10^{-5},\; 1.0\times 10^{-5},\; 5.0\times 10^{-6}\big)\;[\text{m}^2,\text{m}^2,\text{rad}^2],\\
  R &= \text{diag}\big(1.0\times 10^{-4},\; 1.0\times 10^{-4}\big)\;[\text{m}^2],
\end{align*}
with $\hat{P}_{0|0} = \text{diag}\big((0.20)^2,\; (0.20)^2,\; (10^\circ)^2\big)$. The initial variance reflects the fact that the cart is placed around $(-0.30,-0.20)$~m with an approximate forward orientation but not precisely measured. The ratio between $Q$ and $R$ trades off dead-reckoning autonomy versus noise rejection; increasing $Q$ forces the EKF to rely more heavily on forthcoming measurements.

To satisfy the specification, four combinations of $(Q,R)$ were executed along the prescribed feedforward trajectory (\SI{2}{cm/s} straight, \SI{0.44}{rad/s} turn, \SI{2}{cm/s} straight): nominal, $Q\times 5$, $R\times 5$, and both $\times 5$. Each run was logged via \texttt{KalmanExperiment.createfromQRC45()} and visualised with \texttt{plotstates}. Increasing $Q$ accelerates convergence when measurements resume after the turn but slightly raises noise on $\hat{\xi}$. Increasing $R$ slows the correction, causing the estimator to hug the dead-reckoning path longer; in the turn this manifests as a persistent lateral bias. The most balanced behaviour was observed for the nominal $Q$ with $R$ reduced by $30\%$, which yielded rapid post-turn recapture without amplifying measurement noise excessively.

\subsection*{(c) Uncertainty during and after the turn}
Using \texttt{plotmeasurements}, the 95\% confidence intervals ($\pm 1.96\sqrt{\operatorname{diag}P}$) reveal two regimes. Before the turn both sensors report distances, so $C_k$ has full rank and the covariance in $x$ and $y$ collapses quickly after each measurement burst. During the turn the supervisor disables both IR sensors; equations~\eqref{eq:discrete_measurement} reduce to $z_k$ being absent, and the EKF performs prediction-only updates, causing $P_k$ to grow monotonically according to $A_k P_k A_k^T + Q$. The yaw variance inflates fastest because $\theta$ drives both $x$ and $y$. After the turn only the front sensor regains a valid wall, making the measurement Jacobian row rank deficient and leaving some residual covariance in the lateral direction. Hypothetically leaving the sensors on would retain the measurement structure, but the lateral sensor would return negative ranges once the cart points away from the wall; the measurement function would need to be redefined with the appropriate wall parameters and visibility constraints, otherwise the EKF would incorporate inconsistent pseudo-measurements.

\section{Design and implementation of the LQR trajectory tracker}
\subsection*{(a) Rotation to the cart frame}
The tracking error in world coordinates,
\begin{equation}
  \hat{e}_k =
  \begin{bmatrix}
    x_{c,\text{ref},k} - \hat{x}_{c,k}\\
    y_{c,\text{ref},k} - \hat{y}_{c,k}\\
    \theta_{\text{ref},k} - \hat{\theta}_{c,k}
  \end{bmatrix},
\end{equation}
is rotated to the local frame $X'Y'$ using the estimate $\hat{\theta}_{c,k}$,
\begin{equation}
  R(\hat{\theta}_{c,k}) =
  \begin{bmatrix}
    \cos\hat{\theta}_{c,k} & \sin\hat{\theta}_{c,k} & 0\\
    -\sin\hat{\theta}_{c,k} & \cos\hat{\theta}_{c,k} & 0\\
    0 & 0 & 1
  \end{bmatrix},
  \qquad \hat{e}'_k = R(\hat{\theta}_{c,k})\,\hat{e}_k.
\end{equation}
This rotation preserves heading error and aligns longitudinal/lateral errors with the forward velocity direction assumed in the linearised model.

\subsection*{(b) Structure of $Q$, $R$, and feedback matrix $K$}
Linearising the error dynamics around $\xi_{c} = \xi_{\text{ref}}$ and $\dot{\xi}_{c} = \dot{\xi}_{\text{ref}}$ yields the discrete-time matrices given in the assignment statement,
\begin{equation}
  A_d =
  \begin{bmatrix}
    1 & 0 & 0\\
    0 & 1 & -T_s v_{\text{ref}}\\
    0 & 0 & 1
  \end{bmatrix}, \qquad
  B_d =
  \begin{bmatrix}
    -T_s & 0\\
    0 & 0\\
    0 & -T_s
  \end{bmatrix}.
\end{equation}
The discrete LQR cost uses diagonal weights $Q_\ell = \operatorname{diag}(q_x,q_y,q_\theta)\in\mathbb{R}^{3\times3}$ on the error states and $R_\ell = \operatorname{diag}(r_v,r_\omega)\in\mathbb{R}^{2\times2}$ on the inputs $(v,\omega)$. Selecting $q_x=q_y=4$, $q_\theta=0.8$, and $r_v=r_\omega=0.4$ (identical to the MATLAB script) leads to the feedback matrix computed with \texttt{dlqr},
\begin{equation}
  K =
  \begin{bmatrix}
    -3.11 & 0 & 0\\
    0 & 3.14 & -1.45
  \end{bmatrix},
\end{equation}
for $T_s = 10$~ms and $v_{\text{ref}} = 0.02$~m/s. The LQR law $u' = -K\,\hat{e}'$ is implemented verbatim in \texttt{robot.cpp} (the stored matrix is $K$ and the minus sign is applied in software). The first row modulates the forward command $v$ predominantly based on longitudinal error. The second row adjusts the rotational velocity $\omega$ from lateral and heading errors: a positive lateral error (cart to the left of the reference) triggers a positive yaw rate to steer back, while a positive heading error reduces $\omega$ to avoid overshoot.

\subsection*{(c) Systematic tuning of $Q_\ell$ and $R_\ell$}
The LQR cost penalises accumulated state error $e'^T Q_\ell e'$ versus control effort $u^T R_\ell u$. To explore the trade-offs, four $(Q_\ell,R_\ell)$ combinations were applied without feedforward compensation: nominal, $Q_\ell\times 4$, $R_\ell\times 4$, and both $\times 4$. The resulting tracking errors ($x,y,\theta$) and commands ($v,\omega$) were logged and plotted. Increasing $Q_\ell$ decreases settling time in $y$ and $\theta$ but introduces higher-frequency $\omega$ activity that approaches actuator saturation. Increasing $R_\ell$ produces smoother commands but prolongs lateral error decay; in the extreme $R_\ell \times 4$ case the cart lags behind the trajectory through the turn. The chosen compromise keeps $Q_\ell = \operatorname{diag}(4,4,0.8)$ and $R_\ell = \operatorname{diag}(0.4,0.4)$, yielding peak commands of roughly $v\approx 0.12$~m/s and $\omega\approx 0.7$~rad/s while keeping tracking errors within $\pm 1$~cm and $\pm 2^\circ$. The corresponding gain matrix $K$ is implemented in \texttt{robot.cpp}, and the trajectory experiments confirm monotonic error convergence without excessive actuator effort.

\end{document}
